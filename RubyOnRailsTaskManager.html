<html>
<head>
	<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Amethysta|Duru+Sans">
    <style>
	h1{
		color:#DB3556;	
	}
	ol{
		color: #BA1E4A;
	}
	a{
		color: #BA1E4A;
		text-decoration: none;
	}
	h2{
		color:#88BAA3;
	}
	body{
		background-color:#EAEDE4;
	}
      p {
        font-family: 'Amethysta', serif;
		font-size: 20px;
		color:#254F4D;
      }
	  xmp{
		font-family: 'Duru Sans', sans-serif;
		background-color:#E4E6C3;
		border:1px solid #BA1E4A;
		font-size: 16px;
		color: #BA1E4A;
	  }
	  #terminal{
		font-family: 'Duru Sans', sans-serif;
		font-size: 14px;
		border:1px solid black;
		color:#88BAA3;
		background-color:#6E6E6E;
	  }		  
	  #file{
		font-family: 'Duru Sans', sans-serif;
		font-size: 14px;
		color:#848484;
	  }	  
    </style>
</head>
<body>
	<h1>How to: Task Manager App</h1>
	<h2>Getting Started: Simple Homepage and the Bootstrap Front End Framework</h2>
	<p>
		I'm using my RubyOnRailsQuickStart guide to get started on a new RoR project: a task manager.
	</p>

	<div id="terminal">
		$ rails new taskManager
	</div>
	<p>
		Generate a new homepage
	</p>
	<div id="terminal">
		$ rails generate controller pages home
	</div>
	<p>
		Add the route to our homepage. 
	</p>
		<div id="file">/config/routes.rb</div> 
	<xmp>
		get "pages/home"
	</xmp>
	<p>Change the above to</p>
	<xmp>
		root "pages#home"
	</xmp>
	<p>I'll just update the landing page so we can see the difference:</p>
	<div id="file">app/views/pages/home.html.erb</div> 
	<xmp>
		<h1>Welcome to my task manager app</h1>
	</xmp>
	<p>Let's add bootstrap</p>


	<div id="file">/Gemfile</div> 

	<xmp>
		gem 'bootstrap-sass'
	</xmp>
	<p>After installing a new gem:</p>
	<div id="terminal">
		$ bundle install
	</div>
	<p>
		We'll create a new SCSS file, which is a precompiler for CSS:
	</p>
	<div id="file">app/assets/stylesheets/bootstrap_and_customization.css.scss</div> 
	<xmp>
		@import 'bootstrap';
	</xmp>
	<p>
		Now we can restart the server.
	</p>
	<div id="terminal">
		$ rails server
	</div>
	<p>
		Now we want the html we're rendering to use the bootstrap css:
	</p>
	<div id="file">views/layouts/application.html.erb</div>
	<xmp>	
		 <div class="container">
			  <%= yield %>
		 </div>
	</xmp>
	<p>
	Create the partial header for the navigation bar
	</p>
	<div id="file">app/views/layouts/_header.html.erb</div>
	<p>
	Add the link to the partial and the navigation bar:
	</p>
	<div id="file">app/views/layouts/application.html.erb</div>
	<xmp>
		 <%= render 'layouts/header' %>
	</xmp>

	<div id="file">app/views/layouts/_header.html.erb</div>
	<xmp>
		<nav class="navbar navbar-default" role="navigation">
		  <!-- Brand and toggle get grouped for better mobile display -->
		  <div class="navbar-header">
			<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
			  <span class="sr-only">Toggle navigation</span>
			  <span class="icon-bar"></span>
			  <span class="icon-bar"></span>
			  <span class="icon-bar"></span>
			</button>
			<a class="navbar-brand" href="#">Task Manager</a>
		  </div>

		  <!-- Collect the nav links, forms, and other content for toggling -->
		  <div class="collapse navbar-collapse navbar-ex1-collapse">
			<ul class="nav navbar-nav navbar-right">
			  <li><%= link_to "Home", root_path %></li>
			</ul>
		  </div><!-- /.navbar-collapse -->
		</nav>
	</xmp>	

	<p>
		We'll need to update our javascript to require bootstrap:
	</p>
	<div id="file">app/assets/javascripts/application.js</div>
	<xmp>
		...
		//= require jquery
		//= require jquery_ujs
		//= require bootstrap
		//= require turbolinks
		//= require_tree .
	</xmp>	 
	<p>
		We'll add a viewport for the intial load:
	</p>
	<div id="file">views/layouts/application.html.erb</div>
	<xmp>
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
	</xmp>	
	
	<h2>Devise User Authentication</h2>	
	
	<p>Now we'll add and install the devise gem to handle users.</p>
		<div id="file">/Gemfile</div>
		<xmp>
			gem 'devise'
		</xmp>

	<div id="terminal">
	$ bundle install<br/>
	$ rails generate devise:install
	</div>		

	<p>Update our view and header partial to try to log us in</p>	
	<div id="file">app/views/pages/home.html.erb</div>
	<xmp>
		<div class="jumbotron center">
			 <h1>Welcome to my app!</h1>
			 <% if user_signed_in? %>
				  # do something
			 <% else %>
			   <p>
				 <%= link_to "Log in", new_user_session_path, class: "btn btn-default btn-lg" %>
				 <%= link_to "Sign up", new_user_registration_path, class: "btn btn-primary btn-lg" %>
			   </p>
		  <% end %>  
		</div>
	</xmp>

	<div id="file">app/views/layout/_header.html.erb</div>
	<xmp>
		<ul class="nav navbar-nav navbar-right">
			<li><%= link_to "Home", root_path %></li>
			<li><%= link_to "About", about_path %></li>
			<% if user_signed_in? %>
			  <li><%= link_to "Account Settings", edit_user_registration_path %></li>
			  <li><%= link_to "Log out", destroy_user_session_path, method: :delete %></li>
			<% else %>
			  <li><%= link_to "Sign in", new_user_session_path %></li>
			<% end %>
		</ul>
	</xmp>

	<h2>Modeling Our Tasks</h2>	
	<p>Since everything in ruby is a resource, we need to define what kinds of objects we want and hour they relate to each other. We know we have users and they can have many goals. A goal can have many tasks. Tasks can have many subtasks. Tasks and subtasks can have due dates, completion dates, and status (enum: Needs work, on track, completed). I also want a concept of charts: daily, weekly, and monthly task chart: things like waking up early, taking a 30 min walk, or eating your veggies. We'll use scaffolds, which generate the model, view and controller parts for us all at once (as well as test code).</p>
	<div id="terminal">
	$ rails generate scaffold tasks description:string dueData:timestamp progress:integer<br/>
	$ rake db:migrate #run the migration
	</div>	
	<p>Our model, controller and views have all been generated for us. We'll add our authentication in for creating a new task</p>
		<div id="file">app/views/tasks/index.html.erb</div>
	<xmp>
		<% if user_signed_in? %>
		  <%= link_to 'New Task', new_task_path %>
		<% end %>
	</xmp>
	<p>We can do the same thing for habits (the things we can check of daily, weekly, or monthly) and goals. For now we'll keep goals general, just as a description string and a done boolean.</p>	
	<div id="terminal">
	$ rails generate scaffold habits description:string done:boolean interval:integer<br/>
	$ rails generate scaffold goals description:string done:boolean<br/>	
	$ rake db:migrate #run the migration
	</div>
	<div id="file">app/views/habits/index.html.erb</div>
	<xmp>
		<% if user_signed_in? %>
		  <%= link_to 'New Habit', new_habit_path %>
		<% end %>
	</xmp>
	<div id="file">app/views/habits/goals.html.erb</div>
	<xmp>
		<% if user_signed_in? %>
		  <%= link_to 'New Goal', new_goal_path %>
		<% end %>
	</xmp>
	<p>Let's update our nav bar to show these new items </p>
	<div id="file">app/views/habits/goals.html.erb</div>
	<xmp>
		  <!-- Collect the nav links, forms, and other content for toggling -->
		  <div class="collapse navbar-collapse navbar-ex1-collapse">
			<ul class="nav navbar-nav navbar-right">
				<li><%= link_to "Goals", root_path %></li>
				<li><%= link_to "Tasks", tasks_path %></li>
				<li><%= link_to "Habits", habits_path %></li>                
				<% if user_signed_in? %>
				  <li><%= link_to "Account Settings", edit_user_registration_path %></li>
				  <li><%= link_to "Log out", destroy_user_session_path, method: :delete %></li>
				<% else %>
				  <li><%= link_to "Sign in", new_user_session_path %></li>
				<% end %>
				  <li>
					<%= link_to new_goal_path do %>
					  <span class="glyphicon glyphicon-plus"></span> New Goal
					<% end %>
				  </li>
			</ul>
		  </div><!-- /.navbar-collapse -->
	</xmp>
	<div id="file">config/routes.rb</div>
	<xmp>
		TaskManager::Application.routes.draw do
		  resources :goals

		  resources :habits

		  resources :tasks

		  devise_for :users
		  root "goals#index"
		  get "goals" => "pages#goals"
		  get "tasks" => "pages#tasks"
		  get "habits" => "pages#habits"  
		end
	</xmp>	
	<p>We also want to make sure that we only can see, edit, etc the goals, tasks and habits that belong to us. That means we'll need to add some associations. We need to associate users to habits, goals, and tasks. But additionally, tasks and habits can belong to goals and tasks can even belong to other tasks (subtasks) and we want to capture this relationship. For the user association we'll use some of devise's methods to build the objects. So we'll need to update the model, controllers, and views to reflect this.</p>	
	<div id="file">app/models/task.rb</div>
	<xmp>
		class Task < ActiveRecord::Base
			belongs_to :user
			belongs_to :goal
		end
	</xmp>		
	<div id="file">app/models/habit.rb</div>
	<xmp>
		class Habit < ActiveRecord::Base
			belongs_to :user
			belongs_to :goal
		end
	</xmp>		
	<div id="file">app/models/goal.rb</div>
	<xmp>
		class Goal < ActiveRecord::Base
			belongs_to :user
			has_many :tasks
			has_many :habits			
		end
	</xmp>	
	<div id="file">app/models/user.rb</div>
	<xmp>
		class User < ActiveRecord::Base
		  devise :database_authenticatable, :registerable,
				 :recoverable, :rememberable, :trackable, :validatable
		  has_many :goals
		  has_many :tasks
		  has_many :habits
		end
	</xmp>	
	 <div id="terminal">
	 $ rails generate migration add_user_id_to_habits user_id:integer:index<br/>
	 $ rails generate migration add_user_id_to_goals user_id:integer:index<br/>
	 $ rails generate migration add_user_id_to_tasks user_id:integer:index<br/>
	 $ rails generate migration add_goal_id_to_tasks goal_id:integer:index<br/>	
	 $ rails generate migration add_goal_id_to_habits goal_id:integer:index<br/>	 
	 $ rake db:migrate<br/>
	  </div>
	<div id="file">app/controller/goals_controller.rb</div>
	<xmp>
		class GoalsController < ApplicationController
		  before_action :correct_user, only: [:show, :edit, :update, :destroy]
		  before_action :authenticate_user!, except: [:index]
		.
		.		  
		  def index
			@goals = Goal.all
		  end		  
		.
		.		
		  def new
			@goal = current_user.goals.build
		  end

		  # POST /goals
		  # POST /goals.json
		  def create
			@goal = current_user.goals.build(goal_params)
		.
		.
		  private
			def correct_user
			  @goal = current_user.goals.find_by(id: params[:id])
			  redirect_to goals_path, notice: "Not authorized to edit this goal" if @goal.nil?
			end  			
	</xmp>	
	<div id="file">app/controller/habits_controller.rb</div>
	<xmp>
		class HabitsController < ApplicationController
		  before_action :correct_user, only: [:show, :edit, :update, :destroy]
		  before_action :authenticate_user!, except: [:index]	
		.
		.		  
		  def index
			@habits = Habit.all
		  end		  
		.
		.			  
		.
		.		  
		  def new
			@habit = current_user.habits.build
		  end

		  # POST /habits
		  # POST /habits.json
		  def create
			@habit = current_user.habits.build(habit_params)
		.
		.
		  private
			def correct_user
			  @habit = current_user.habits.find_by(id: params[:id])
			  redirect_to habits_path, notice: "Not authorized to edit this habit" if @habit.nil?
			end  			
	</xmp>	
	<div id="file">app/controller/tasks_controller.rb</div>
	<xmp>
		class TasksController < ApplicationController
		  before_action :correct_user, only: [:show, :edit, :update, :destroy]
		  before_action :authenticate_user!, except: [:index]
		.		  
		  def index
			@tasks = Task.all
		  end			  
		.
		.		
		  def new
			@task = current_user.tasks.build
		  end

		  # POST /task
		  # POST /task.json
		  def create
			@task = current_user.tasks.build(task_params)
		.
		.
		  private
			def correct_user
			  @task = current_user.tasks.find_by(id: params[:id])
			  redirect_to tasks_path, notice: "Not authorized to edit this task" if @task.nil?
			end  		
	</xmp>	
	<div id="file">app/views/tasks/index.html.erb</div>
	<xmp>
			<h1>Listing tasks</h1>
			<br>
			<% if user_signed_in? %>
			  <table>
				<thead>
				  <tr>
					<th>Description</th>
					<th>Due date</th>
					<th>Progress</th>
					<th></th>
					<th></th>
					<th></th>
				  </tr>
				</thead>

				<tbody>
				  <% @tasks.each do |task| %>
					<% if task.user == current_user %>
					  <td><%= task.description %></td>
					  <td><%= task.dueDate %></td>
					  <td><%= task.progress %></td>
					  <td><%= link_to 'Show', task %></td>    
					  <div class="actions">
						<%= link_to edit_task_path(task) do %>
						<span class="glyphicon glyphicon-edit"></span>
						  Edit
						<% end %>
						<%= link_to task, method: :delete, data: { confirm: 'Are you sure?' } do %>
						<span class="glyphicon glyphicon-trash"></span>
						  Delete
						<% end %>
					  </div>
					<% end %>
				  <% end %>
				</tbody>
			  </table>

			  <%= link_to 'New Task', new_task_path %>
			<% end %>
		
	</xmp>
	<p>We'll update the views the same way for the goals and habits also, which I did not list out above. Now let's update the UI and stylize this a bit more. We want to list out the tasks and habits in rows. At this point I'm also realizing Ruby doesn't have the notion of enums like other languages I'm used to (C++\Java), so we'll need to add strings as these values and just drop these integers from our table. So instead of trying to migrate this, I'm just going to roll all the way back, edit the migration files and then migrate again. So now I'll edit my old migration files and change the integer for interval, progress, etc to strings and then do a db:migrate again.</p>
	 <div id="terminal">
		$ rake db:rollback STEP=9<br/>		
		$ rake db:migrate<br/>		
	 </div>	
	 <p> So we'll start back up the server and look at our data. So since we're changing our model, we need to update the edit forms also. So we'll change the below. We also want to make sure users only can select specific strings that we allow. Let's add some validation into the model about what string values are acceptable.</p>
	<div id="file">app/views/habits/_form.html.erb</div>
	<xmp>
	  <div class="field">
		<%= f.label :interval %><br>
		<%= f.number_field :interval %>
	  </div>		
	</xmp>	
	<p>And change it to the below, we'll do this for the other forms too.</p>
	<xmp>
	  <div class="field">
		<%= f.label :interval %><br>
		<%= f.select :interval, options_for_select(%w[Daily Weekly Monthly]) %>    
	  </div>	
	</xmp>	
	<div id="file">app/models/habit.rb</div>
	<xmp>
		validates_format_of :interval, :with => /\A(?:(Daily)|(Weekly)|(Monthly))\Z/, :on => :create		
	</xmp>	
	<div id="file">app/models/task.rb</div>
	<xmp>
		validates_format_of :progress, :with => /\A(?:(Not Started)|(Needs Work)|(On Track)|(Complete))\Z/, :on => :create		
	</xmp>
	<div id="file">app/views/tasks/_form.html.erb</div>
	<xmp>
	  <div class="field">
		<%= f.label :interval %><br>
		<%= f.number_field :interval %>
	  </div>		
	</xmp>	
	<p>So now we have a nice view of everything and we can update things. The habits should reset on their intervals and when we do this reset we could keep track of streaks. We'll need to run a cron job (set up a periodic task) to update the habits. We also know we only need to run this once a day. That might not be strictly true, as different users in different timezones would want it reset at different times, but for simplicity we'll just do midnight for us. Update: This does not work on windows, but if you're on a system that supports cron, you can do this locally: We'll use the whenever gem https://github.com/javan/whenever and follow the instructions for installing and setting up the scheduler.</p>
	<div id="terminal">$gem install whenever</div>
	<div id="file">app/models/habit.rb</div>
	<xmp>
	gem 'whenever', :require=> false
	</xmp>
	<div id="terminal">$bundle install</div>
	<div id="terminal">$wheneverize .</div>
	<p>This creates a schedule.rb config file, in this file we'll be able to call rake tasks. In your application take a look at the Rakefile. </p>	
	<div id="file">/Rakefile</div>
	<xmp>
	# Add your own tasks in files placed in lib/tasks ending in .rake,
	# for example lib/tasks/capistrano.rake, and they will automatically be available to Rake.
	</xmp>	
	<p>This means we can create a new file, let's name it reset_habits.rake and put it in /lib/tasks. Rake tasks let us call things command line, in our case we'll want to be able to clear all the :done values of our habits periodicially. Create some test data using your app, and then run the rails console from the terminal. Inspect a habit. </p>
	<div id="terminal">$rails console</div>	
	<div id="terminal">>Habit.inspect </div>	
	<p>Now you have a view into the state of the database, you'll be able to test if your rake command is working by running it, and then rechecking to see if it cleared the done flag on the Habits. We can get a little bit more familiar with rake tasks, below are some examples you add and run from the commandline.</p>
	<div id="file">/Rakefile</div>
	<xmp>
			namespace :demotask do
			
			  desc "display the current environment of rake"
			  task :current_environment do
				puts "You are running rake task in #{Rails.env} environment"
			  end

			  desc "count number of records in given model table"
			  task :count_records, [:model] => :environment do |t, args| # task with both arguments and dependency
				args.with_defaults(:model => "Habit" )
				model_calss_name = Object.const_get(args.model) # this is very important as when you#pass argument it come as a string, so you must convert it to model class
				puts "No of records is #{model_calss_name.count}"
			  end

			  desc "see what happen when you call a modal method without loading environment"
			  task :without_environment do
				puts Habit.first.done
			  end
			  
			  desc "load environment before operating on any model object"
			  task :with_environment => :environment do
				puts Habit.first.done
			  end  
			  
			 end
	</xmp>	
	<p>We can run some of these commands from the command line and see what they do. Above there is a method that does not pass the environment, try running it. You'll see an error message, now try running the one with environment.</p>	
	<div id="terminal">$rake demotask:without_environment<br>
	$rake aborted!<br>
	uninitialized constant User<br>
	$rake demotask:with_environment!<br>
	dependency<br>	
	true<br>	
	</div>
	<p>So we can see from count_records how to access the model, and we will update it using the ActiveRecord update method. We can also add some logging to see what's going on.</p>	
	<div id="file">/Rakefile</div>
	<xmp>
		namespace :habits do
			desc "Rake task to reset the weekly habits"
			task :resetWeekly => :environment do
				puts "Value of habits after clear "
				habits = Habit.all
				habits.each do |habit|
					habit.update(done: false)
					puts habit.done
				end
			puts "#{Time.now} - Success!"
			end
	</xmp>	
	<p>Using the rails console you can toggle that, and test out the rest of the resets needed: resetDaily, resetWeekly, resetMonthly. Since I"m on a windows machine and the gem above which would work for a unix system with a cron file, I'm going to instead deploy this whole thing to the cloud and use heroku's scheduler to call the rake tasks.</p>		
	<h2 id="3">Deploying to the Cloud with Heroku and using Heroku Scheduler</h2>
	<p>Heroku lets us deploy the app to the cloud. You'll need to sign up for an heroku account. It only uses a postgres database though so you will need to update your gemfile to use this in production.</p>

	<div id="file">/Gemfile</div>
	<xmp>
		group :development, :test do
			 gem 'sqlite3'
		end

		group :production do
			 gem 'pg'
			 gem 'rails_12factor'
		end
	</xmp>
	<div id="terminal">
		$heroku login <br>
		Email: (enter your email) <br>
		Password (enter your password - it will show blank and that's fine) <br>
		$ heroku keys:add<br>
		$ heroku create<br>
		$ git push heroku master<br>
		$ heroku run rake db:migrate<br>
		$ heroku addons:add scheduler:standard<br>
	</div>	
	<p>Heroku's documentation: https://devcenter.heroku.com/articles/scheduler#installing-the-add-on is pretty good at describing how to set up the scheduler. The schedule will just run our rake tasks that reset the habits. You can test them on heroku by setting up some data.<p>
	<div id="terminal">$ heroku run rake habits</div>	
</body>
</html>